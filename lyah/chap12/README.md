# chap12 - 初识

## monad

Monad 是函数式编程中的一个核心概念，特别是在 Haskell 中，它扮演着极其重要的角色。
Monad 提供了一种强大的方式来处理函数式编程中的副作用（如输入/输出、状态变化、异常处理等），同时仍然保持代码的纯净和表达性。

### Monad 的定义

在 Haskell 中，Monad 是通过 Monad 类型类定义的，它至少需要实现两个基本操作：`>>=`（读作"bind"）和`return`。

- **`return`**：接受一个值并将其放入 Monad 上下文中。它通常用于将普通值提升（或包装）到 Monad 中，使得这个值可以在 Monad 的上下文中使用。

- **`>>=` (Bind)**：接受一个 Monad 值和一个函数，这个函数可以处理 Monad 中的值，并返回一个新的 Monad。
  Bind 操作符用于串联 Monad 操作，允许在保持上下文一致的情况下，将多个 Monad 操作链接起来。

### Monad 的直观理解

可以将 Monad 想象为带有额外上下文或效果的容器。例如，`Maybe` Monad 可以表示一个可能失败的计算，
`IO` Monad 表示有副作用的计算（如读写文件），而`List` Monad 可以表示多路径的计算。

- **Maybe Monad**：用于处理可能的失败或缺失值。`Just`表示存在的值，而`Nothing`表示缺失值。
- **IO Monad**：用于处理输入/输出操作，使得可以在纯函数式语言中安全地执行这些操作。
- **List Monad**：用于处理多个计算路径，每个元素可以看作是一个计算的结果。

### Monad 的作用

Monads 的主要作用是允许我们以一种结构化和安全的方式组合使用副作用。通过 Monad，我们可以：

- **组合计算**：即使这些计算包含额外的上下文或副作用，也能以近似于纯函数的方式进行。
- **隐藏复杂性**：Monad 抽象可以帮助我们隐藏副作用处理的复杂性，让我们能够更专注于业务逻辑。
- **增强表达性**：通过 Monad，我们可以用更富有表达力的方式编写代码，尤其是在处理错误、列表处理或异步操作时。

### Monad Laws

为了确保 Monad 的一致性和可组合性，所有的 Monad 实现都应该遵循三个法则：左单位律、右单位律和结合律。

- **左单位律**：`return a >>= f` 相当于 `f a`。
- **右单位律**：`m >>= return` 相当于 `m`。
- **结合律**：`(m >>= f) >>= g` 相当于 `m >>= (\x -> f x >>= g)`。

这些法则确保了 Monad 操作的结果不会依赖于它们是如何组合的，
从而允许开发者以可预测的方式构建复杂的操作链。

## functor、applicative、monad

Monad 是 Haskell 编程语言中的一个高级概念，它是一个抽象的接口（或类型类），用于表示带有上下文的计算。
Monads 提供了一种强大的方式来处理副作用、异步操作、异常处理等，在纯函数式编程语言中尤其重要，因为它们允许我们在不牺牲函数式编程原则的前提下进行这些操作。
要理解 Monad，我们首先需要了解几个基本概念：**Functor**、**Applicative**和**Monad**自身。

### Functor

在 Haskell 中，**Functor**是一种可以被映射过的类型构造器。
最基本的 Functor 定义包含一个函数`fmap`，这个函数可以取一个函数`a -> b`和一个 Functor 包裹的值`f a`，
然后将这个函数应用到这个值上，得到`f b`。

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

### Applicative

**Applicative**是比 Functor 更强大的抽象，它不仅支持对包裹的值应用一个普通的函数，还允许你对包裹的函数应用包裹的值。
它引入了两个基本操作：`pure`，用于将值包裹进 Applicative；`<*>`（应用操作符），用于应用包裹的函数到包裹的值上。

```haskell
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```

### Monad

**Monad**是 Applicative 的一个扩展，提供了更强大的操作，使得可以将一系列计算链接起来，其中后一个计算可以依赖于前一个计算的结果。
Monad 引入了`>>=`（绑定操作符），它允许你将一个包裹的值和一个函数链接起来，这个函数可以从一个普通值产生一个包裹的值。

```haskell
class Applicative m => Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a -- `return` 是 `pure` 的别名
```

Monad 的关键在于它能够处理包含上下文的值（例如可能失败的计算、包含副作用的计算等），并且能够通过`>>=`操作符以一种连贯和灵活的方式将这些计算链接起来。
这种能力使得 Monad 在错误处理、状态传递、IO 操作等方面非常有用。

### Monad 的直观理解

可以把 Monad 想象成一个可以执行计算的上下文或环境，它提供了一种机制，让你可以顺序地执行计算，同时处理计算中可能出现的复杂情况（如错误、无结果等）。
Monad 通过`>>=`（绑定）允许这些计算顺序连接，而不需要担心中间步骤的具体实现细节。

### 为什么 Monad 重要

Monad 在 Haskell 中的重要性在于，它们提供了一种在不引入副作用的情况下处理复杂计算的方法。
它们使得代码更加模块化，更易于理解和维护，同时还保留了 Haskell 的纯函数式特性。
通过使用 Monad，开发者可以编写出既安全又强大的应用程序逻辑。

## do 只是语法糖

是的，`do`语法在 Haskell 中确实是 Monad 操作的语法糖。
它提供了一种更清晰、更易读的方式来编写使用 Monads 的代码，特别是在进行多个顺序操作时。
`do`语法允许你以接近命令式编程的风格来编写函数式代码，这在处理像`IO`这样的操作或其他需要 Monad 来处理的复杂逻辑时非常有用。

### `do`语法的工作原理

`do`语法背后的机制是基于 Monad 的`>>=`（绑定）操作符。
每一行在`do`块中的操作都会被转换成使用`>>=`来链式调用，使得上一个操作的结果可以传递给下一个操作。

考虑以下的`do`表达式：

```haskell
do
  x <- action1
  action2 x
  y <- action3
  action4 y
```

这个`do`块实际上是以下形式的语法糖：

```haskell
action1 >>= ((\x -> action2 x) >> action3 >>= (\y -> action4 y))
```

将`action1`的值传递给右边。`action3 >>= (\y -> action4 y)`得到`action4 action3`，
然后`\x -> action2 x >> action4 action3`得到`action4 action3`，
这里`action2 x`依然被执行了，但是结果并没有参与到`action4 action3`的计算之中。

do 这个语法糖确实妙 确实妙：他通过`>>`略过了不绑定值的表达式；通过`x >>= y`将 x 绑定到 y 中。

在这个转换中：

- 使用`x <- action1`来绑定`action1`的结果到`x`。
- 然后`action2 x`被执行（注意，如果`action2`不产生绑定，则使用`>>`而不是`>>=`）。
- 接着，`y <- action3`绑定`action3`的结果到`y`。
- 最后，`action4 y`被执行。

### 使用`do`语法的优点

- **可读性**：`do`语法提供了一种直观的方式来编写连续的 Monad 操作，特别是当涉及多个步骤时，每一步都依赖于前一步的结果。
- **减少样板代码**：它减少了编写重复的`>>=`和匿名函数的需要，使代码更加简洁。
- **模拟命令式编程**：虽然 Haskell 是一种纯函数式编程语言，
  `do`语法允许开发者以一种模拟命令式编程的风格来表达复杂的操作流程，这对于习惯了命令式语言的开发者来说更加自然。

总的来说，`do`语法是一种有效的工具，
它使得在 Haskell 中使用 Monad 来进行复杂的操作和逻辑流程变得更加容易和直观。

## monadic value

在 Haskell 中，一个 monadic value（Monad 值）是指那些被包裹在 Monad 类型构造器中的值。
Monad 是一种抽象概念，用于表示具有某种上下文或额外信息的计算。
Monadic 值不仅携带原始数据，还携带了关于这个数据如何被处理或解释的附加信息，这些信息对于 Monad 的类型和行为至关重要。

### 例子和解释

让我们通过一些例子来更好地理解 monadic 值：

- **`Maybe` Monad**: `Maybe`类型用于表示一个可能存在也可能不存在的值。
  一个`Maybe`类型的 monadic 值可以是`Just a`（表示一个存在的值`a`）或`Nothing`（表示值不存在）。
  这里，`Just a`或`Nothing`都是 monadic 值，因为它们被`Maybe` Monad 包裹，并且携带了存在性的上下文信息。

- **`[a]`（列表）Monad**: 在 Haskell 中，列表也可以被看作是一个 Monad，其中列表的元素被视为可能存在多个值的情况。
  一个列表（比如`[1, 2, 3]`）是一个 monadic 值，因为它被列表 Monad 包裹，并且表示了一个元素序列的上下文。

- **`IO` Monad**: `IO`类型用于表示涉及输入/输出操作的值。
  一个`IO`类型的值（比如`getLine`，一个读取标准输入一行文本的操作）是一个 monadic 值，
  因为它被`IO` Monad 包裹，并且携带了 IO 操作的上下文。

### Monadic 值的特点

- **上下文**：Monadic 值携带了关于计算上下文的信息，这可以是错误处理、IO 操作、可能的不存在值等。
- **链式操作**：Monadic 值可以通过 Monad 提供的操作（如`>>=`）以一种链式的方式进行处理，其中后续的操作可以依赖于前一个操作的结果。
- **副作用的封装**：对于某些 Monad（如`IO`），monadic 值允许函数式语言在不放弃纯粹性的前提下处理副作用。

通过使用 Monad，Haskell 允许开发者以一种类型安全且表达力强的方式处理复杂的操作和数据转换，
同时保持代码的清晰和简洁。Monadic 值是这一过程中不可或缺的一部分，因为它们代表了 Monad 抽象的具体实例。

## non-determinism

非确定性（Non-determinism）是一个计算概念，指的是在执行过程中，从给定的状态出发，存在多种可能的路径或结果。
在不同的上下文中，非确定性可以有不同的含义和实现方式。

### 在计算机科学中的非确定性

- **算法**：在算法领域，一个非确定性算法在其执行过程中可以做出随机选择，导致多个可能的结果。
  这与确定性算法不同，后者对于同一输入总是产生相同的输出。
- **自动机理论**：在自动机理论中，非确定性自动机（如非确定性有限自动机，NFA）在某一状态下，对于一个输入符号可以有多个可能的转移状态。
  这与确定性自动机（如确定性有限自动机，DFA）形成对比，后者在任何状态下对每个输入符号只有一个唯一的转移状态。
- **并发编程**：在并发编程中，非确定性出现在程序的不同部分可能以不可预知的顺序执行时，
  这通常取决于调度器的行为和外部条件，可能导致每次运行程序时都产生不同的结果。

### 在函数式编程中的非确定性

在函数式编程，尤其是在 Haskell 这样的纯函数式语言中，
非确定性可以通过特定的抽象来表达，例如使用 Monad 来模拟非确定性计算。
最常见的非确定性 Monad 包括：

- **List Monad**：在 Haskell 中，列表可以用来表示非确定性计算，其中一个值可以有多个可能的结果。
  列表 Monad 通过列表的绑定操作（`>>=`）允许以声明式方式表达这种计算，其中每个计算步骤可以为之后的步骤生成多个后续路径。
- **Maybe Monad**：虽然通常用于表示可能的失败，`Maybe`类型也可以看作是一种简单的非确定性形式，
  其中一个计算可能有一个结果（`Just`值）或没有结果（`Nothing`）。

## list comprehension 不过是一个语法糖

```haskell
-- [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
-- [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]
listOfTuples :: [(Integer, Char)]
listOfTuples = do
  n <- [1, 2]
  ch <- ['a', 'b']
  return (n, ch)
```

看看下面这个：

```haskell
-- mzero 定义
instance MonadPlus [] where
    mzero = []
    mplus = (++)

-- guard 定义
guard :: (MonadPlus m) => Bool -> m ()
guard True = return ()
guard False = mzero

--
ghci> guard (5 > 2) >> return "cool" :: [String]
["cool"]
ghci> guard (1 > 2) >> return "cool" :: [String]
[]

--
ghci> guard (5 > 2) :: Maybe ()
Just ()
ghci> guard (1 > 2) :: Maybe ()
Nothing
ghci> guard (5 > 2) :: [()]
[()]
ghci> guard (1 > 2) :: [()]
[]
```

这个就有点：C++ 模板的 IFINAE(instance failed is not an error) 的感觉

```haskell
ghci> [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
[7,17,27,37,47]
```

这里，如果`guard(elem '7' $ show x)`是`[]`（`""`）或者是`Nothing`的话，这个`>>`就会短路

## >> 的短路逻辑

```haskell
[1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
```

- `[1..50]`是一个列表，包含从`1`到`50`的整数。
- `>>=`是列表 Monad 的 bind 操作。它将列表中的每个元素应用到后面的函数中。
- `\x -> guard (elem '7' $ show x) >> return x`是一个匿名函数，接受一个整数`x`，首先检查`x`转换为字符串后是否包含字符`'7'`，
  如果包含，则通过`return x`返回包含这个整数的列表；如果不包含，则“短路”，不产生任何结果。

### `guard` 函数

`guard`是一个与 Monad 相关的函数，其定义如下：

```haskell
guard :: MonadPlus m => Bool -> m ()
```

- 当`guard`的参数为`True`时，它会产生 Monad 的单位值（对于列表来说，就是`[()]`，一个包含单个单位元素的列表）。
- 当`guard`的参数为`False`时，它产生 Monad 的零值（对于列表来说，就是`[]`，一个空列表）。

### 短路逻辑

在您的代码中，`guard ('7' `elem` show x)`会针对每个`x`值检查`'7'`是否为其一部分：

- 如果`'7'`是`x`的一部分，`guard`函数产生一个非空列表（`[()]`），然后使用`>>`操作符与`return x`组合。
  由于`>>`操作符忽略左侧操作的结果，并只返回右侧操作的结果，因此`return x`被执行，返回一个只包含`x`的列表。
- 如果`'7'`不是`x`的一部分，`guard`返回一个空列表（`[]`）。根据`>>`的定义，当左侧操作为一个空列表时，整个表达式短路，即不产生任何结果。

这就是为什么最终结果只包含那些在其十进制表示中至少包含一个`'7'`的数字。
`guard`和`>>`一起工作，实现了条件过滤的短路逻辑，这是列表 Monad 特有的行为表现。
在其他 Monad（如`Maybe`）中，`guard`的行为会略有不同，但基本原理相同：它依赖于 Monad 定义的零值来决定是否继续执行后续操作。

### list comprehension

```haskell
sevensOnly :: [Int]
sevensOnly = do
    x <- [1..50]
    guard ('7' `elem` show x)
    return x
```
