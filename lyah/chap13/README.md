# chap13

## list（单向链表）的 ++ 导致的左结合与右结合的问题

在 Haskell 中，列表的连接操作（`++`）的效率问题通常涉及到操作的结合性。
当你连续使用`++`操作连接多个列表时，结合方式（即是左结合还是右结合）会对性能产生显著影响。
这是因为`++`的性能特性和列表的内部表示有关。

### 左结合 vs. 右结合

- **左结合**意味着操作从左向右进行。例如，表达式`a ++ b ++ c`在左结合的情况下会被解释为`(a ++ b) ++ c`。首先连接`a`和`b`，然后将结果与`c`连接。
- **右结合**意味着操作从右向左进行。同样的表达式`a ++ b ++ c`在右结合的情况下会被解释为`a ++ (b ++ c)`。首先连接`b`和`c`，然后将`a`与结果连接。

### 效率问题

列表的连接操作`++`的效率问题来源于 Haskell 列表的实现方式。
Haskell 中的列表是单向链表，当你执行`list1 ++ list2`时，Haskell 需要遍历整个`list1`来找到它的末尾，然后将`list2`接在`list1`的末尾。
这个操作的时间复杂度是 O(n)，其中 n 是`list1`的长度。

- 当连接操作是**左结合**时，如`(a ++ b) ++ c`，首先连接`a`和`b`，如果`a`很长，这个操作就已经需要较多时间。
  然后，将结果（已经是`a`和`b`的长度之和）与`c`连接，需要再次遍历`a ++ b`的结果，导致效率较低。
- 相反，如果操作是**右结合**，如`a ++ (b ++ c)`，首先连接较短的列表`b`和`c`，这个操作相对较快。
  然后，将`a`连接到前面的结果上。在整个过程中，每个列表只被遍历一次来找到它的末尾，这使得右结合的方式更加高效。

### 实践建议

在实际编程中，推荐使用那些自然地产生右结合结构的构造，如使用`:`操作符（头部插入）构建列表，
然后一次性反转列表，或者使用更高效的数据结构（如`Data.Sequence`），特别是在处理大量数据时。
避免在循环或递归中使用左结合的列表连接操作，因为这会导致性能问题。

## (->) r 函数类型

在 Haskell 中，`(->) r`表示的是一个从类型`r`到某个类型的函数。
换句话说，任何接受单个参数的函数都可以被视为`(->) r`的实例，其中`r`是这个函数的参数类型。

举一个具体的例子，考虑下面这个简单的函数：

```haskell
addOne :: Int -> Int
addOne x = x + 1
```

这个函数`addOne`的类型是`Int -> Int`，它接受一个`Int`类型的参数并返回一个`Int`类型的结果。
在`(->) r`的表示法中，这个函数的类型可以被理解为`(->) Int`的一个实例，其中返回值类型是`Int`。
这里，`r`被具体化为`Int`，表示函数的参数类型。

要更深入地探讨`(->) r`作为一个类型构造器，我们可以看看它如何与高阶类型类如`Functor`和`Applicative`交互。
例如，考虑`Functor`类型类的实例：

```haskell
instance Functor ((->) r) where
    fmap = (.)
```

在这个实例中，`(->) r`被视为一个`Functor`，`fmap`的行为等价于函数组合操作符`(.)`。
这意味着你可以将一个函数映射到另一个函数上，得到一个组合了两个函数行为的新函数。例如：

```haskell
double :: Int -> Int
double x = x * 2

-- 使用fmap对函数进行组合
doubleThenAddOne :: Int -> Int
doubleThenAddOne = fmap addOne double

-- doubleThenAddOne 等价于 addOne . double
```

在这个例子中，`double`函数的类型是`Int -> Int`，与`addOne`相同。
通过`fmap`（实际上是函数组合`(.)`），我们创建了一个新的函数`doubleThenAddOne`，它先将一个整数翻倍，然后加一。
这里，`(->) Int`作为`Functor`的一个实例，展示了如何通过高阶函数和类型类将函数组合起来，创造出强大的抽象和灵活的代码结构。

## context 与 (->) r

在 Haskell 中，`context`和`(->) r`两个概念虽然看似不相关，
实际上都与函数式编程的核心理念紧密相连，特别是在处理函数和类型类时的行为。
下面分别解释这两个概念，并探讨它们之间的联系。

### Context（上下文）

上下文在 Haskell 中通常指的是类型约束的列表，这些约束出现在类型声明或类型类声明中的`=>`符号左侧。
上下文用于指定一个或多个类型变量必须满足的条件（例如，它们必须是某个类型类的实例）才能进行某些操作。
这使得函数可以在更加抽象的层面上工作，因为它们不依赖于具体的类型，而是依赖于类型的行为。

### (->) r

`(->) r`是函数类型的一种表示方式，其中`r`是函数的参数类型。
在 Haskell 中，函数也被视为值，因此`->`实际上是一个接受两个类型参数的类型构造器：参数类型和返回值类型。
特别是当你看到类似`Functor (->) r`或`Applicative (->) r`时，这表明函数类型可以是`Functor`或`Applicative`的实例，
其中的`r`是固定的参数类型，而变化的部分是函数的返回值类型。

### 它们之间的联系

现在，让我们探讨`context`和`(->) r`之间的联系。
在 Haskell 中，当你使用类型类（如`Functor`、`Applicative`等）时，经常会遇到需要在上下文中指定类型约束的情况。
对于`(->) r`来说，当它被用作`Functor`或其他类型类的实例时，实际上展示了函数式编程中的一个重要概念：高阶函数。
这些高阶函数可以接受其他函数作为输入，或者返回另一个函数作为输出。

例如，`fmap`的类型签名在`Functor`类中定义为`fmap :: Functor f => (a -> b) -> f a -> f b`。
当应用于`(->) r`时，`fmap`的行为就变成了函数组合，因为`(->) r`是`Functor`的一个实例。
这里的`context`就是`Functor f =>`，它指出了`fmap`操作适用于任何`Functor`实例。
对于`(->) r`形式的函数，这意味着你可以将一个函数映射到另一个函数上，得到一个新的函数，这正是函数式编程强大的表达能力和灵活性的体现。

综上所述，`context`在描述`(->) r`（特别是作为类型类实例时）的行为和约束时发挥了重要作用，展示了 Haskell 中类型系统的表达力和函数式编程的灵活性。
