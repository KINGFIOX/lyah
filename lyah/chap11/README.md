# chap11 - functor

## functor

functor 需要满足 以下这两个定律。

### 定律 1 （幺元）

```haskell
ghci> fmap id (Just 3)
Just 3
ghci> id (Just 3)
Just 3
ghci> fmap id [1..5]
[1,2,3,4,5]
ghci> id [1..5]
[1,2,3,4,5]
ghci> fmap id []
[]
ghci> fmap id Nothing
Nothing
```

### 定律 2 （与计算顺序无关）

```haskell
fmap (f . g) = fmap f . fmap g
```

## functor 的意义

这个问题涉及到几个重要的函数式编程概念：`Functor`、`Applicative Functor`以及它们如何用于处理可能存在的值或操作。
首先，让我们分别理解为什么需要`Functor`和`Applicative Functor`，然后再解释为什么`Just add <*> Just 3 <*> Just 5`是有意义的。

### 为什么需要`Functor`

`Functor`允许我们将一个普通的函数应用到一个包装过的值（如`Maybe`、`List`等）上。
例如，如果你有一个值`Just 3`和一个函数`add 3`，你不能直接将这个函数应用到`Just 3`上，
因为`add 3`期望一个普通的整数，而不是一个`Maybe`类型的值。这时，你可以使用`fmap`：

```haskell
fmap (add 3) (Just 5)  -- 结果是 Just 8
```

`fmap`处理了`Maybe`这样的上下文，使函数应用成为可能。

### 为什么引入`Applicative Functor`

尽管`Functor`很强大，但它有一定的限制。
特别是，当你有一个包装过的函数（如`Just (add 3)`）而不是一个普通的函数时，你无法使用`fmap`将其应用到包装过的值上。
这是因为`fmap`期望的是一个普通的函数，而不是一个已经被包装的函数。

`Applicative Functor`扩展了`Functor`，提供了一种方式来应用 包装过的函数 到包装过的值上。它通过使用`<*>`操作符实现：

```haskell
Just (add 3) <*> Just 5  -- 结果是 Just 8
```

这里，`<*>`取了一个包装过的函数`Just (add 3)`和一个包装过的值`Just 5`，并将函数应用到了值上。

### 为什么不直接使用`add 3 5`

当你在处理的值可能不存在（比如`Nothing`）时，直接使用`add 3 5`会忽略掉这种可能性。
使用`Maybe`类型和`Applicative Functor`允许你在保留这种可能性的同时进行计算。例如：

```haskell
Just add <*> Just 3 <*> Just 5  -- 结果是 Just 8
Just add <*> Nothing <*> Just 5  -- 结果是 Nothing
```

在第二个例子中，由于其中一个参数是`Nothing`，整个表达式的结果也是`Nothing`，这反映了计算可能因为缺少必要的值而失败的情况。

### 总结

虽然对于确定存在的值，直接使用`add 3 5`更简单直接，但在处理可能不存在的值时，
`Functor`和`Applicative Functor`提供了一种强大的方式来安全地进行计算，同时处理值可能不存在的情况。
这种方法增加了代码的健壮性，使得你可以构建更安全、更表达力强的函数式编程解决方案。

## applicative maybe

这段代码定义了`Maybe`类型作为`Applicative Functor`的一个实例。
`Applicative`是比`Functor`更强大的抽象，它不仅允许我们将普通函数应用到包装值（或者说上下文值）上，
还允许我们将包装（或者说上下文化）的函数应用到包装的值上。
`Applicative`类型类定义在`Control.Applicative`模块中，它要求实现两个函数：`pure`和`<*>`（读作 apply）。

### `pure`函数

`pure`函数用于将一个普通值包装到`Applicative`的上下文中。
对于`Maybe`类型，`pure`的实现简单地将一个值包装在`Just`中：

```haskell
pure = Just
（上面这一段省略了 参数）
```

这意味着，如果你有一个值`x`，`pure x`会产生`Just x`。

### `<*>`操作符

`<*>`操作符用于将包装（上下文化）的函数应用到包装的值上。`Maybe`的`<*>`实现考虑了几种不同的情况：

1. **如果函数本身不存在（`Nothing`）**，那么无论应用到什么值上，结果都是`Nothing`：

   ```haskell
   Nothing <*> _ = Nothing
   ```

   这表示如果你尝试使用一个不存在的函数，你得到的结果也将不存在。

2. **如果函数存在（`Just f`）**，则使用`fmap`将这个函数`f`应用到另一个`Maybe`值上：

   ```haskell
   (Just f) <*> something = fmap f something
   ```

   这里的`something`可以是`Just x`或者`Nothing`。
   如果`something`是`Just x`，`fmap f something`会将`f`应用到`x`上，并将结果包装在`Just`中。
   如果`something`是`Nothing`，根据`fmap`的定义，结果也会是`Nothing`。

### `Applicative`实例的意义

通过定义`Maybe`为`Applicative`的一个实例，我们可以在可能不存在的值上进行复杂的函数应用操作，同时保持对可能的失败的显式处理。
这增强了代码的表达力和安全性，允许我们构建更健壮的函数式编程解决方案。例如：

```haskell
Just (+3) <*> Just 5  -- 结果是 Just 8
Just (+3) <*> Nothing -- 结果是 Nothing
```

在第一个例子中，我们将存在的函数`(+3)`应用到存在的值`5`上，得到`Just 8`。
在第二个例子中，尽管函数存在，但是由于值不存在（`Nothing`），
最终的结果也是`Nothing`。这种模式使得错误处理变得更加流畅和自然。

上看这里的`Just (+3)`就是一个：包装过的函数

## pure

在函数式编程中，特别是在 Haskell 语言的上下文中，`pure`是`Applicative`类型类的一个基本函数。
它的主要作用是将一个值包装到某个`Applicative Functor`的上下文中。
通过这种方式，`pure`提供了一种将普通值提升（lift）为`Applicative`值的机制，使得这个值可以参与到`Applicative`风格的操作中去。

### `Applicative`类型类和`pure`

`Applicative`类型类是定义在`Control.Applicative`模块中的，它扩展了`Functor`的功能，
不仅允许将普通函数应用到一个上下文值（例如，可能的值、列表、IO 操作等）上，
还允许将上下文中的函数应用到上下文中的值上。`Applicative`的定义如下：

```haskell
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```

（这里的 宽右箭头`=>`表示：约束类型；`::` 表示 函数签名的意思）

`f (a -> b)`是约束一个`(a -> b)`类型的函数是`f`的

这里：

- `pure`函数接受一个普通值`a`，并返回一个类型为`f a`的`Applicative`值，其中`f`是某个`Applicative Functor`。
- `<*>`（读作 apply）是`Applicative`的另一个核心操作，它用于将包装（或上下文化）的函数应用到包装的值上。

### `pure`函数的作用

- **提升值**：`pure`使得普通值可以被提升到`Applicative`的上下文中，这为后续的`Applicative`操作（如`<*>`）提供了输入。
- **上下文化**：通过将值放入上下文中，`pure`允许这个值携带额外的信息，如可能的失败（`Maybe`）、多个结果（`[]`，即列表）、副作用（`IO`）等。

### 示例

假设你想在`Maybe`上下文中使用数字`5`：

```haskell
pure 5 :: Maybe Int
```

这会返回`Just 5`，即数字`5`被提升到了`Maybe`上下文中，表明这是一个存在的值。

对于列表`Applicative`：

```haskell
pure 5 :: [Int]
```

这会返回`[5]`，即将`5`提升到列表上下文中，表明这是一个单元素列表。

### 总结

`pure`是`Applicative`类型类中的一个关键函数，它提供了一种机制来将普通值包装到`Applicative Functor`的上下文中。
这允许值参与到更复杂的`Applicative`操作中，同时携带上下文信息，如可能的错误、多个可能的结果或其他副作用。
`pure`的存在是`Applicative`编程模式能够工作的基础。

## (->) r

在 Haskell 中，`(->) r`表示一个从类型`r`到另一类型的函数类型构造器。
这是 Haskell 中表示函数类型的方式，其中`r`是函数的参数类型，而返回类型则是另外指定的。
简单来说，`(->) r`可以被看作是一个接受单个参数类型`r`并返回一个新的类型的类型构造器。

### 函数类型构造器

当我们谈论`(->) r`时，我们实际上是在讨论一个部分应用的类型构造器。
在 Haskell 中，`(->)`是一个接受两个类型参数的类型构造器：
第一个参数是输入类型，第二个参数是输出类型。
当我们只提供第一个参数（如`(->) r`）时，我们得到的是一个期望另一个类型作为输出类型的部分应用类型构造器。

### 类型签名示例

假设我们有一个函数`f`，它接受一个`Int`类型的参数并返回一个`Bool`类型的结果。这个函数的类型可以写作：

```haskell
f :: Int -> Bool
```

在这里，`->`用于分隔函数的参数类型和返回类型。
如果我们只关注函数的输入部分，并且想表达一个从`Int`到任何类型的函数，
我们可以使用`(->) Int`这样的表示方式，虽然这种用法在实际编程中不太常见，因为我们通常会指定函数的完整类型签名。

### 函数作为 Functor

一个有趣的用例是将函数看作`Functor`。在 Haskell 中，函数也可以是`Functor`的实例。
具体来说，对于任何类型`r`，`(->) r`是一个`Functor`。这意味着我们可以将`fmap`应用于函数上，这在 Haskell 中实际上等同于函数的组合。例如：

```haskell
fmap (+1) (*2)
```

这将创建一个新的函数，该函数先将其输入乘以 2，然后将结果加 1。
在这个例子中，`(+1)`和`(*2)`都是类型为`Int -> Int`的函数，而`fmap`的应用等价于使用函数组合操作符`(.)`：

```haskell
(+1) . (*2)
```

### 总结

总的来说，`(->) r`在 Haskell 中表示一个从类型`r`到另一类型的函数的类型构造器。
这种表示方法揭示了 Haskell 类型系统的一些高级特性，包括函数类型的一等公民地位，以及将函数作为抽象数据结构来操作的能力。

## fmap 与 (.)

在 Haskell 中，`fmap`和`(.)`两个函数都是高阶函数，它们的函数签名分别如下：

### `fmap`

`fmap`的函数签名定义在`Functor`类型类中，它的一般形式是：

```haskell
fmap :: Functor f => (a -> b) -> f a -> f b
```

这意味着`fmap`接受一个类型为`a -> b`的函数和一个`Functor`包装的类型为`a`的值，
然后返回一个`Functor`包装的类型为`b`的值。它将给定的函数应用到`Functor`内部包含的值上。

### `(.)`（函数组合）

`(.)`的函数签名定义在`Prelude`中，它的一般形式是：

```haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
```

这意味着`(.)`接受两个函数：一个类型为`b -> c`的函数和一个类型为`a -> b`的函数，
然后返回一个新的函数，这个新函数接受一个类型为`a`的值，并返回一个类型为`c`的值。
`(.)`用于组合两个函数，使得第二个函数的输出成为第一个函数的输入。

### 两者的区别和联系

- **`fmap`**是`Functor`类型类的一部分，用于将函数应用到`Functor`包装的值上。
  它适用于任何实现了`Functor`接口的数据类型，如`Maybe`、列表（`[]`）、`Either a`等。

- **`(.)`**是函数组合操作符，用于将两个函数组合成一个新的函数。
  它是函数式编程中的一个基础概念，允许构建复杂的函数通过简单函数的组合。

尽管它们的目的不同（一个是映射，另一个是组合），
但`fmap`和`(.)`都体现了函数式编程的核心原则，即通过函数和高阶抽象来构建程序逻辑。

## fmap 与 functor

1. **直接应用函数到`Maybe`类型**：确实，您不能直接将一个普通的函数，如`add 3`，应用到`Maybe`类型的值上，比如`Just 5`。
   这是因为`add 3`期望一个普通的数字作为输入，而`Just 5`是一个`Maybe`类型的值。

2. **使用`fmap`应用函数**：为了将函数应用到`Maybe`类型的值上，您应该使用`fmap`。
   不过，表达式`fmap add 3 Just 5`也是不正确的。正确的方式是使用`fmap`将函数应用到`Maybe`值上，
   比如`fmap (add 3) (Just 5)`，其中`add`是一个接受两个参数的函数，比如普通的加法操作`+`。
   如果`add`是一个预定义的函数，它应该像这样被定义：`add x y = x + y`。
   但在 Haskell 中，您通常直接使用`+`操作符，而不是定义一个`add`函数。

正确的表达式应该是：

```haskell
fmap (+ 3) (Just 5)
```

或者，使用部分应用函数和`fmap`：

```haskell
fmap (`add` 3) (Just 5)  -- 假设add定义为add x y = x + y
```

1. **`Applicative`风格**：如果您想使用类似`add 3 Just 5`的语法，
   您实际上可以通过`Applicative`来实现，
   因为这允许您将包装在`Maybe`中的函数应用到包装在`Maybe`中的值上：

```haskell
import Control.Applicative

pure (+) <*> pure 3 <*> Just 5
```

这里，`pure (+)`将加法函数提升到`Applicative`上下文中（在这个例子中是`Maybe`），
然后使用`<*>`将其应用到`Just 5`上。

总的来说，您不能直接将函数`add 3`应用到`Maybe`类型的值`Just 5`上，
但您可以使用`fmap`或`Applicative`风格来达到类似的效果。

## `<$>`

在 Haskell 中，`<$>`是`fmap`函数的中缀操作符。
它用于将一个函数应用到一个`Functor`上的值。
基本上，`<$>`和`fmap`完成相同的任务，
只是语法不同。使用`<$>`通常可以让代码更加简洁易读，特别是当你在进行函数链式调用时。

### 类型签名

`<$>`的类型签名和`fmap`一样，为：

```haskell
(<$>) :: Functor f => (a -> b) -> f a -> f b
```

这意味着，它接受一个类型为`a -> b`的函数和一个`Functor`包装的类型为`a`的值，
然后返回一个`Functor`包装的类型为`b`的值。

### 示例

假设你有一个函数`not :: Bool -> Bool`，它取一个布尔值并返回它的反值，
以及一个`Maybe Bool`值`Just True`。你可以使用`<$>`来将`not`应用到`Maybe`中的值：

```haskell
not <$> Just True  -- 结果是 Just False
```

如果你有一个列表`[1, 2, 3]`和一个函数`(*2) :: Int -> Int`，你可以将这个函数应用到列表中的每个元素：

```haskell
(*2) <$> [1, 2, 3]  -- 结果是 [2, 4, 6]
```

### 为什么使用`<$>`

使用`<$>`而不是`fmap`的主要原因是它可以提高代码的可读性，
尤其是在函数组合和链式调用中。例如，比较以下两种方式：

使用`fmap`：

```haskell
fmap (*2) (fmap (+3) (Just 5))
```

使用`<$>`：

```haskell
(*2) <$> ((+3) <$> Just 5)
```

或者更简洁地：

```haskell
(*2) . (+3) <$> Just 5
```

通过使用`<$>`，你可以更清楚地看到数据流向和函数应用的顺序，使得代码更容易理解。

### 总结

`<$>`是`fmap`的中缀版本，用于将函数应用到`Functor`包装的值。
它提供了一种更为优雅和链式的方式来编写函数式代码，特别是在进行多步骤的函数应用和组合时。

## `<*>`

假设`f`的类型是`c -> (d -> a)`。
这意味着`f`是一个函数，接受一个类型为`c`的参数，
返回另一个函数，这个返回的函数的类型是`d -> a`。

然后，`g`的类型是`c -> d`。
这意味着`g`是一个函数，
接受一个类型为`c`的参数，并返回一个类型为`d`的结果。

在这种情况下，`f <*> g`的结果是一个新的函数，这个新函数接受`f`和`g`共同的输入类型`c`，
然后首先将`g`应用到这个输入上，得到`g`的输出（类型`d`），随后将`f`应用到相同的输入上，
得到`f`的输出（一个类型为`d -> a`的函数），最后将`g`的输出作为这个函数的输入，得到类型为`a`的结果。

所以，更准确地说，如果你有：

- `f :: c -> (d -> a)`
- `g :: c -> d`

那么`f <*> g`的结果是一个类型为`c -> a`的函数，这个函数的行为可以描述为：

```haskell
(\x -> (f x) (g x))
```

这里，`x`是`c`类型的输入，`(f x)`应用`f`到`x`上，得到一个函数，
`(g x)`应用`g`到相同的`x`上，得到一个值，然后将这个值作为`(f x)`得到的函数的参数。

因此，如果`f <*> g`是针对函数的`Applicative`操作，那么你不能直接表达为`f y (g x)`，
因为`f`和`g`都应用到了相同的输入上。正确的表达应该是将同一个输入`x`分别应用到`g`和`f`上，然后将`g`的结果作为参数传递给`f`的结果。

## applicative 上下文

当你看到表达式`(+3) <*> (*100)`，这里实际上涉及到`Applicative`的用法，但需要注意的是，对于函数来说，它们的`Applicative`实例的行为略有不同于你描述的`c -> b -> a`模式。让我们澄清这一点。

### 函数的`Applicative`实例

首先，对于函数`(->) r`来说，它的`Applicative`实例允许你将函数上下文中的操作合并。
其`pure`函数和`<*>`操作符的行为定义如下：

- **`pure`**：将一个值提升到函数上下文中，等同于忽略输入并总是返回该值的常量函数。

  ```haskell
  pure x = \_ -> x
  ```

- **`<*>`**：接受两个函数`f`和`g`，其中`f`的类型为`r -> (a -> b)`，`g`的类型为`r -> a`，
  然后返回一个新的函数，这个新函数对于给定的输入，首先使用相同的输入调用`g`得到`a`，然后将`a`作为参数调用`f`得到的函数，最终返回类型为`b`的结果。

### 表达式`(+3) <*> (*100)`

在表达式`(+3) <*> (*100)`中：

- `(+3)`可以被看作是`a -> b`的函数，但在这个`Applicative`上下文中，我们将其视为`r -> (a -> b)`，
  其中`r`是任意类型（因为加法不依赖于除了被加数以外的任何输入），`a`和`b`都是数值类型（比如`Int`或`Float`）。
- `(*100)`是`r -> a`的函数，它同样不依赖于特定的输入类型`r`，只是将输入乘以 100。

因此，使用`<*>`操作符将这两个函数组合：

- 这意味着对于任意输入`x`，我们首先计算`(*100) x`得到`100x`，然后将这个结果作为参数传递给`(+3)`。

所以，`(+3) <*> (*100)`创建了一个新的函数，这个函数将其输入乘以 100，然后加 3。这可以更清楚地表示为：

```haskell
\x -> (+3) (($ x) (*100))
```

或更简单地，因为`($ x)`是应用操作，我们可以省略它，直接写作：

```haskell
\x -> (+3) (( *100) x)
```

或更直接地：

```haskell
\x -> (+3) (x * 100)
```

因此，这个组合的函数实际上是`(a -> b)`类型，接受一个数值`x`（`a`），乘以 100，加 3，返回最终结果（`b`）。
这里没有`c -> b -> a`的模式，因为我们在这个表达式中只是简单地组合了两个函数来操作同一个输入值。

## 一个例子

```haskell
ghci> (+) <$> (+3) <*> (*100) $ 5
```

相当于 `fmap (+) ((+3) <*> (*100))`，然后再将 5 传入这个函数中。
根据 applicative functor 的上下文性质，得到`\x -> (x+3) (x*100)`，
最后被 fmap，得到 `fmap (+) (\x -> (x+3) (x*100))` => `\x -> (x+3) + (x*100)`

## liftA2

在 Haskell 中，`liftA2` 是一个函数，属于`Applicative`类型类，
用于将一个二元函数应用于两个具有`Applicative`结构的参数。
简而言之，`liftA2`允许你将普通函数转换为能够在`Applicative`上下文中工作的函数。

`liftA2`的类型签名如下：

```haskell
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
```

这里是如何解读这个类型签名的：

- `Applicative f` 表明`f`必须是一个`Applicative`的实例。
- `(a -> b -> c)` 是一个接受两个参数（类型为`a`和`b`）的函数，并返回一个结果（类型为`c`）。
- `f a` 和 `f b` 分别是两个`Applicative`结构，包含类型为`a`和`b`的值。
- `f c` 是函数的结果，同样是一个`Applicative`结构，包含类型为`c`的值。

`liftA2`的作用是将一个二元函数应用于两个`Applicative`值中的内容，然后将结果包装回同一种`Applicative`结构中。
这使得你可以在不脱离`Applicative`上下文的情况下组合多个`Applicative`操作。

这里有一个简单的例子来展示`liftA2`的用法：

假设你有两个`Maybe`值（`Maybe`是`Applicative`的一个实例）和一个普通函数，比如一个二元加法函数：

```haskell
add :: Num a => a -> a -> a
add x y = x + y
```

你可以使用`liftA2`将`add`函数应用于两个`Maybe`值：

```haskell
liftA2 add (Just 5) (Just 3)
```

结果会是`Just 8`，因为`add`被应用于`Just 5`和`Just 3`中的值，然后结果被包装回`Maybe`中。

如果任一参数是`Nothing`，结果也会是`Nothing`，这体现了`Applicative`的失败传递特性：

```haskell
liftA2 add (Just 5) Nothing
```

结果会是`Nothing`。

`liftA2`广泛用于多种场景，特别是在需要在`Applicative`上下文中组合多个操作时，它提供了一种优雅的方式来处理这些情况。

## newType 与 data

在 Haskell 中，`newtype` 关键字用于创建现有类型的新包装。
它与 `data` 关键字类似，用于定义新的数据类型，但 `newtype` 用于创建单一构造器、单一字段的新类型，它在运行时不引入额外的开销。
`newtype` 保证了类型安全，同时提供了与底层类型相同的运行时性能。这种机制非常适合用于类型转换和确保通过类型的不同来强制执行特定的约束和抽象。

### 使用 `newtype` 的基本语法：

```haskell
newtype NewTypeName = ConstructorName UnderlyingType
```

- `NewTypeName` 是新类型的名称。
- `ConstructorName` 是用于构造新类型值的构造器名称。
- `UnderlyingType` 是已存在的类型，你希望通过新类型来包装。

### `newtype` 的优点：

- **性能**: 与使用 `data` 定义的类型相比，`newtype` 不会引入额外的运行时开销，因为它在运行时被表示为其包装的类型。
- **类型安全**: `newtype` 允许开发者通过类型区分，即使底层类型相同，也能创建逻辑上不同的类型，这增加了代码的类型安全性。
- **派生**: 可以从其他类型自动派生一些实例（比如 `Eq`, `Ord` 等）。

### 示例：

假设你有一个表示用户 ID 的整数，你希望确保不会意外地将其与其他整数类型的数据混淆。你可以使用 `newtype` 来定义一个新的 `UserID` 类型：

```haskell
newtype UserID = UserID Int
```

这里，`UserID` 是新的类型名称，也是构造器的名称，而 `Int` 是底层类型。

#### 创建 `UserID` 值

要创建一个 `UserID` 类型的值，你使用构造器：

```haskell
myUserID :: UserID
myUserID = UserID 123
```

#### 使用 `newtype` 定义的类型

当你定义了一个 `newtype`，你可能需要定义如何操作这个新类型。例如，你可能需要一个函数来提取 `UserID` 的 `Int` 值：

```haskell
getUserId :: UserID -> Int
getUserId (UserID id) = id
```

在这个函数中，`(UserID id)` 是一个模式匹配表达式，它解构了 `UserID`，提取出底层的 `Int` 值。

### 使用 `newtype` 的场景

- **性能关键**: 当你需要包装一个类型但不想引入运行时开销时。
- **类型安全**: 当你希望通过类型区分来增强代码的可读性和安全性时。
- **类型约束**: 当你需要为特定类型定义特定的实例或行为时，比如为一个特定的类型实现 `Monoid` 或其他类型类的实例。

`newtype` 是 Haskell 类型系统的一个强大工具，允许开发者在保持性能的同时增加类型的抽象和安全性。
